<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>浅谈C++中的类 - Jun's Blog</title>
<meta name=theme-color><meta name=description content="类的基本思想 数据抽象 封装 接口 实现 类的性质 构造 当一个对象被创造出来，就称之为构造．构造的过程实际上是调用了类定义的构造函数 构造函数不能被声明为"><meta name=author content="Jun"><link rel="preload stylesheet" as=style href=https://www.junz.org/main.min.css><link rel=preload as=image href=https://www.junz.org/theme.png><script defer src=https://www.junz.org/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.junz.org/favicon.ico><link rel=apple-touch-icon href=https://www.junz.org/apple-touch-icon.png><meta name=generator content="Hugo 0.121.1"><meta itemprop=name content="浅谈C++中的类"><meta itemprop=description content="类的基本思想 数据抽象 封装 接口 实现 类的性质 构造 当一个对象被创造出来，就称之为构造．构造的过程实际上是调用了类定义的构造函数 构造函数不能被声明为"><meta itemprop=datePublished content="2021-03-20T01:00:10+08:00"><meta itemprop=dateModified content="2021-03-20T01:00:10+08:00"><meta itemprop=wordCount content="1374"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="浅谈C++中的类"><meta name=twitter:description content="类的基本思想 数据抽象 封装 接口 实现 类的性质 构造 当一个对象被创造出来，就称之为构造．构造的过程实际上是调用了类定义的构造函数 构造函数不能被声明为"><link rel=canonical href=https://www.junz.org/post/cpp_oop_overview/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://www.junz.org>Jun's Blog</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/>Home</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">浅谈C++中的类</h1><div class="text-sm antialiased opacity-60"><time>Mar 20, 2021</time>
<span class=mx-1>&#183;</span>
<span>Jun</span></div></header><section><h2 id=类的基本思想>类的基本思想</h2><ul><li>数据抽象</li><li>封装<ul><li>接口</li><li>实现</li></ul></li></ul><h2 id=类的性质>类的性质</h2><h3 id=构造>构造</h3><p>当一个对象被创造出来，就称之为构造．<strong>构造的过程实际上是调用了类定义的构造函数</strong></p><p><strong>构造函数不能被声明为<code>const</code></strong></p><h4 id=直接初始化构造>直接初始化构造</h4><p>这种构造方式调用了初始化构造函数，用参数列表中的参数生成了一个对象</p><p>此构造函数可以被重载，有多个，实际调用参数列表最匹配的那个构造函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>std::string str(&#34;init&#34;)
</span></span></code></pre></td></tr></table></div></div><p>这里是直接初始化，我们实际上是调用了<code>string</code>类的初始化函数，参数是<code>"init"</code>，生成了一个对象</p><h4 id=拷贝构造>拷贝构造</h4><h5 id=拷贝初始化>拷贝初始化</h5><p>利用一个已有的对象初始化另一个对象，称为拷贝初始化</p><p>拷贝构造如果需要的话还会进行类型转换，所以一般其不应该为<code>explicit</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>拷贝构造函数的型参应该为引用类型，因为为了调用拷贝构造函数，我们必须拷贝他的实参，然后我们又将调用拷贝构造函数，形成死循环</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>std::string s1(&#34;direct_init&#34;);
</span></span><span class=line><span class=cl>std::string s2 = s1;
</span></span></code></pre></td></tr></table></div></div><p>这里是拷贝初始化，我们实际上调用了拷贝构造函数，来生成了一个对象</p><h5 id=拷贝赋值运算符>拷贝赋值运算符</h5><p>一个已初始化的对象，进行赋值操作时，实际上调用的就是复制运算符</p><p>它实际上执行了拷贝构造函数和析构函数的工作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>std::string s1(&#34;direct_init&#34;);
</span></span><span class=line><span class=cl>std::string s2;
</span></span><span class=line><span class=cl>s2 = s1;
</span></span></code></pre></td></tr></table></div></div><h5 id=阻止拷贝>阻止拷贝</h5><p>我们可以在参数列表后加上<code>=delete</code>，表示我们禁止拷贝操作</p><p>例如<code>iostream</code>阻止了拷贝，避免多个对象写入或读取相同的<code>IO</code>缓冲</p><h4 id=移动构造>移动构造</h4><p><code>Copy can be expensive. --Bjarne Stroustrup</code></p><p>在重新分配内存时，将旧内存拷贝进新元素是不划算的，尤其是旧元素在此之后将不再被使用时</p><p>一个更好的办法是移动元素，将资源直接转交给新对象</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Foo::Foo(Foo &amp;&amp;f) noexcept : 
</span></span><span class=line><span class=cl>	a(f.a), b(f.b) //直接移动资源
</span></span><span class=line><span class=cl>	{
</span></span><span class=line><span class=cl>	f.a = f.b = nullptr;//源对象之后必须指向不再移动的资源，要保持它进入可析构的状态
</span></span><span class=line><span class=cl>	}
</span></span></code></pre></td></tr></table></div></div><h5 id=移动赋值运算符>移动赋值运算符</h5><p>移动赋值运算符实际上执行了移动构造函数和析构函数的工作</p><h5 id=右值引用>右值引用</h5><p>指必须绑定到右值的引用</p><p>它只能绑定到即将被销毁的对象上</p><p>右值一般是字面量，或求值过程中临时创建的对象</p><p>我们可以显式地将一个左值转换为右值<code>std::move()</code>，于是便可以将右值引用绑定在上面</p><h3 id=析构>析构</h3><p>当一个对象被销毁时，就会自动调用它自身定义的析构函数</p><h3 id=总结>总结</h3><p><strong>以上为类的基本属性，每当使用了一个属性本质上就是调用了相关的函数或方法</strong></p><h3 id=编译器的合成行为>编译器的合成行为</h3><p>如果我们需要编译器生成默认的行为，我们可以在参数列表后架上<code>=default</code>显式地要求生成合成的方法</p><h4 id=合成的拷贝构造函数>合成的拷贝构造函数</h4><p>如果我们没有定义拷贝构造函数，那么编译器会自动生成一个</p><p>它实际上是将对象的成员逐一拷贝给另一个对象</p><ul><li>如果成员为另一个类，就调用他本身的拷贝构造函数</li><li>如果类的成员为内置类型，就直接拷贝</li><li>如果成员为数组，就逐元素拷贝成员</li></ul><h4 id=合成的移动操作>合成的移动操作</h4><p>当我们没有定义拷贝构造函数时，且成员均是可移动时，编译器将自动生成</p><p>当我们定义了拷贝构造函数，且无自定义移动行为时，编译器将会把移动操作定义为删除的函数</p><p>当我们未拷贝构造函数，且成员不可移动，编译器将会把移动操作定义为删除的函数</p><h2 id=访问控制>访问控制</h2><h3 id=public><code>public</code></h3><p>在整个程序中都能被访问，为接口</p><h3 id=private><code>private</code></h3><p>只可以被类的成员函数访问</p><h3 id=protexted><code>protexted</code></h3><p>自身和其派生类有权访问</p><h3 id=友元>友元</h3><p>类可以允许其他类或函数访问他的非公有成员，声明了友元即可</p><h2 id=类的静态成员>类的静态成员</h2><h3 id=声明>声明</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Foo {
</span></span><span class=line><span class=cl>	public:
</span></span><span class=line><span class=cl>		static int a;
</span></span><span class=line><span class=cl>	private:
</span></span><span class=line><span class=cl>		static double b;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=初始化>初始化</h3><p>通常情况下，我们不应该在类的内部初始化类的静态成员</p><p>不过我们可以为静态成员提供<code>const</code>整数类型的类内初始值，且要求静态成员必须为<code>constepxr</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>class</span> <span class=n>Bar</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=n>constexpr</span> <span class=ne>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=性质>性质</h3><p>静态类的成员不与任何对象绑定在一起，也不能被声明为<code>const</code></p><h3 id=访问>访问</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int c = Foo::a;
</span></span></code></pre></td></tr></table></div></div></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://www.junz.org/post/practical_vim/><span class=mr-1.5>←</span><span>Vim实用技巧</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://www.junz.org/post/const_in_cpp/><span>简要剖析const关键字</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=https://www.junz.org>Jun's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>