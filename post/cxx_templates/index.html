<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>C++模板基础 - Jun's Blog</title>
<meta name=theme-color><meta name=description content="函数模板 先看几个简单的例子了解下函数模板是如何使用的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template<typename T> T max(T a, T b) { return b < a ? a : b; } max(1,2); // 隐式指定了模板实参"><meta name=author content="Jun"><link rel="preload stylesheet" as=style href=https://www.junz.org/main.min.css><link rel=preload as=image href=https://www.junz.org/theme.png><script defer src=https://www.junz.org/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.junz.org/favicon.ico><link rel=apple-touch-icon href=https://www.junz.org/apple-touch-icon.png><meta name=generator content="Hugo 0.121.1"><meta itemprop=name content="C++模板基础"><meta itemprop=description content="函数模板 先看几个简单的例子了解下函数模板是如何使用的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template<typename T> T max(T a, T b) { return b < a ? a : b; } max(1,2); // 隐式指定了模板实参"><meta itemprop=datePublished content="2022-02-27T20:39:40+08:00"><meta itemprop=dateModified content="2022-02-27T20:39:40+08:00"><meta itemprop=wordCount content="1682"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="C++模板基础"><meta name=twitter:description content="函数模板 先看几个简单的例子了解下函数模板是如何使用的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template<typename T> T max(T a, T b) { return b < a ? a : b; } max(1,2); // 隐式指定了模板实参"><link rel=canonical href=https://www.junz.org/post/cxx_templates/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://www.junz.org>Jun's Blog</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/>Home</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">C++模板基础</h1><div class="text-sm antialiased opacity-60"><time>Feb 27, 2022</time>
<span class=mx-1>&#183;</span>
<span>Jun</span></div></header><section><h2 id=函数模板>函数模板</h2><p>先看几个简单的例子了解下函数模板是如何使用的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>max</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>b</span> <span class=o>&lt;</span> <span class=n>a</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>max</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span> <span class=c1>// 隐式指定了模板实参为int，由编译器推导
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>max</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span> <span class=c1>// 显式指定了模板实参为int
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=kt>int</span> <span class=n>I</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>add</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>I</span> <span class=o>+</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=o>&lt;</span><span class=mi>42</span><span class=o>&gt;</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>在尖括号间是模板参数列表（template parameter list），其中元素称为模板参数（template parameter），而T 是类型参数，表示任意类型。</p><p>当我们调用了一个函数模板时，我们隐式或显式指定了模板实参（template argument），将其绑定到模板参数上。</p><h3 id=模板类型参数>模板类型参数</h3><p>在上面的例子中的<code>max</code>函数中，有一个模板类型参数（type parameter）。我们可以将类型参数看作类型说明符，可以用它来指定返回类型或函数的参数类型。</p><h4 id=类型推断中的类型转换>类型推断中的类型转换</h4><ul><li>如果调用参数是按引用传递的，任何类型都不被转换</li><li>如果调用参数是按值传递的，那么只有退化（decay）这类转换是被允许的。</li></ul><p>注意类型推断并不适用于默认调用参数，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span> <span class=o>=</span> <span class=s>&#34;&#34;</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>();</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>g</span><span class=p>(</span><span class=n>T</span> <span class=o>=</span> <span class=s>&#34;&#34;</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=n>g</span><span class=p>()</span> <span class=c1>// OK
</span></span></span></code></pre></td></tr></table></div></div><h4 id=非类型参数>非类型参数</h4><p>模板参数不一定要是某种具体的类型，也可以是常规数值。比如上面例子中的<code>add</code>函数。对于非类型参数，C++17后可以不用制定其类型而是用<code>auto</code>进行推导。
以下代码在C++17中也是成立的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>auto</span> <span class=n>X</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>echo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=函数模板的重载>函数模板的重载</h2><ul><li>如果有一个非模板函数和一个与其同名的函数模板共存，并且这个模板可以被实例化为与非模板函数具有相同类型的调用参数，在其他因素完全相同的情况下，优先选择非模板函数。</li><li>如果模板可以实例化出一个更匹配的函数，选择此模板。</li><li>可以显式指定一个空的模板列表，这表明它会被解析成一个模板调用。</li></ul><h2 id=类模板>类模板</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>elems</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>push</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>elem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>top</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>IntStack</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>与函数模板不同，编译器不可以隐式推导出模板参数类型，所以在使用类模板时，我们必须要在模板名后的尖括号内显式提供模板实参。在类模板内部，T可以像普通类型一样被用来声明成员变量和成员函数。在类内部，Stack就表示这个类，但在外部使用时，必须写<code>Stack&lt;T></code>。</p><h3 id=成员模板>成员模板</h3><p>无论是普通类还是模板类都可以包含本身是模板的成员函数。这种成员被称为成员模板（<em><code>member template</code></em>）。</p><p>对于类模板，类和成员各自有自己独立的模板参数。而为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。</p><h3 id=template>.template</h3><p>有时，在调用一个成员模板的时候，有必要显式地指出模板参数。此时，必须使用<code>.template</code>来告诉编译器<code>&lt;</code>后面是一个模板参数列表。具体可以看下面这个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bitset&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>printBitset</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bitset</span><span class=o>&lt;</span><span class=n>N</span><span class=o>&gt;</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>bs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>bs</span><span class=p>.</span><span class=k>template</span> <span class=n>to_string</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>char_traits</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				       <span class=n>std</span><span class=o>::</span><span class=n>allocator</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>bitset</span><span class=o>&lt;</span><span class=mi>5</span><span class=o>&gt;</span> <span class=n>bit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>printBitset</span><span class=p>(</span><span class=n>bit</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=模板类的全特化>模板类的全特化</h3><p>为了特化一个模板，在类模板声明的前面改为<code>template&lt;></code>，并且需要指明所需要特化的类型。这些用于特化类模板的类型被用作模板参数，并且需要紧跟在类名的后面：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>所有其它出现T的地方，都应该被特化为类模板的类型。</p><h3 id=偏特化>偏特化</h3><p>类模板可以被部分特化，这样就可以为某些其它特殊情况提供特殊的实现。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>*</span> <span class=n>top</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>注意特化后的函数接口可能不同，比如<code>top()</code>。</p><h3 id=类型别名>类型别名</h3><p>类型别名有两种形式：</p><ul><li><code>typedef Stack&lt;int> IntStack</code></li><li><code>using IntStack = Stack&lt;int></code></li></ul><p>这一过程称为*<code>alias declaration</code><em>。 在这种情况下我们都只是为一个已存在的类型定义了一个别名，并没有定义新的类型。新的名字称为</em><code>type alias</code>*。</p><h3 id=别名模板>别名模板</h3><p>*<code>alias declaration</code>*也可以被模板化，这样就可以给一组类型取一个方便的名字。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>DequeStack</span> <span class=o>=</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=类成员的别名模板>类成员的别名模板</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>S</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>Ty</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>MyT</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>S</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Ty</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>注意在使用<code>S&lt;T>::Ty</code>是必须在前面加上<code>typename</code>，向编译器表明这是一个类型，否则编译器默认认为只是一个普通成员变量。</p><h2 id=变参模板>变参模板</h2><p>从C++11开始，模板可以接受一组数量可变的参数，这种模板被称为变参模板（variadic template）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=n>T</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>Args</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>arg1</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nf>constexpr</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>...(</span><span class=n>Args</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 编译期if
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>print</span><span class=p>(</span><span class=n>args</span><span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=变参下标>变参下标</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>auto</span><span class=p>...</span> <span class=n>Idx</span><span class=p>,</span> <span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>printRange</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span><span class=o>&amp;</span> <span class=n>coll</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>coll</span><span class=p>[</span><span class=n>idx</span><span class=p>]...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>printRange</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>vec</span><span class=p>);</span> <span class=c1>// =&gt; print(vec[0], vec[2], vec[3])
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://www.junz.org/post/expected_in_cxx23/><span class=mr-1.5>←</span><span>std::expected 基本使用</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://www.junz.org/post/csapp_chap9/><span>CSAPP第九章笔记之虚拟内存</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=https://www.junz.org>Jun's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>