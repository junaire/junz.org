<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>汇编语言之实模式 - Jun's Blog</title><meta name=theme-color><meta name=description content="基础知识 在进入主题前，先总结下关于二进制的一些知识点，我个人认为这非常的令人困惑： 1 bit, 指1位，0或者1 1 byte, 指1个字节，有8位 1 word, 指1个字，有"><meta name=author content="Jun"><link rel="preload stylesheet" as=style href=https://www.junz.org/main.min.css><link rel=preload as=image href=https://www.junz.org/theme.png><script defer src=https://www.junz.org/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.junz.org/favicon.ico><link rel=apple-touch-icon href=https://www.junz.org/apple-touch-icon.png><meta name=generator content="Hugo 0.119.0"><meta itemprop=name content="汇编语言之实模式"><meta itemprop=description content="基础知识 在进入主题前，先总结下关于二进制的一些知识点，我个人认为这非常的令人困惑： 1 bit, 指1位，0或者1 1 byte, 指1个字节，有8位 1 word, 指1个字，有"><meta itemprop=datePublished content="2022-11-06T23:45:13+08:00"><meta itemprop=dateModified content="2022-11-06T23:45:13+08:00"><meta itemprop=wordCount content="3038"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="汇编语言之实模式"><meta name=twitter:description content="基础知识 在进入主题前，先总结下关于二进制的一些知识点，我个人认为这非常的令人困惑： 1 bit, 指1位，0或者1 1 byte, 指1个字节，有8位 1 word, 指1个字，有"><link rel=canonical href=https://www.junz.org/post/asm_realmode/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://www.junz.org>Jun's Blog</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/>Home</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">汇编语言之实模式</h1><div class="text-sm antialiased opacity-60"><time>Nov 6, 2022</time>
<span class=mx-1>&#183;</span>
<span>Jun</span></div></header><section><h1 id=基础知识>基础知识</h1><p>在进入主题前，先总结下关于二进制的一些知识点，我个人认为这非常的令人困惑：</p><ul><li>1 bit, 指1位，0或者1</li><li>1 byte, 指1个字节，有8位</li><li>1 word, 指1个字，有2个字节，16位</li><li>1 dword, 指1个双字，有4个字节，32位</li><li>1 qword, 指1个四字，有8个字节，64位</li></ul><h1 id=8086-处理器>8086 处理器</h1><p>8086是 Intel 公司的第一款16位处理器，诞生于1978年。（对没错，下面的知识源于上个世纪70年代）</p><h2 id=通用寄存器>通用寄存器</h2><p>8086处理器内部有8个16位通用寄存器，如下：</p><ul><li>AX</li><li>BX</li><li>CX</li><li>DX</li><li>SI</li><li>DI</li><li>BP</li><li>SP</li></ul><p>其中，<code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code> 又可以各自拆成2个8位的寄存器来使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>15  8 7   0
</span></span><span class=line><span class=cl>| AH | AL | -&gt; AX
</span></span><span class=line><span class=cl>| BH | BL | -&gt; BX
</span></span><span class=line><span class=cl>| CH | CL | -&gt; CX
</span></span><span class=line><span class=cl>| DH | DL | -&gt; DX
</span></span></code></pre></td></tr></table></div></div><h2 id=段>段</h2><p>内存对于软件来说可以认为是一个由0和1构成的线性的表，而处理器简单来说会从内存中读取内容并执行指令。这就会造成一个问题，也就是程序与数据的二义性，或者说在没有上下文的情况下给你一段内存中的内容，你不知道这到底是数据还是指令。</p><p>我们可以将数据和指令分开各自存放在一块连续的区域，这样处理器只要知道指令区块的起始地址，便可以一直执行下去。而如果需要拿到某个具体的数据或者跳转到一个特定的指令，只需要给出其“段起始地址：段偏移量”即可。</p><p>8086内部有4个段寄存器，分别为：</p><ul><li>CS (Code Segment) 用来指向代码段的起始地址</li><li>DS (Data Segment) 用来指向数据段的起始地址</li><li>ES (Extra Segment) 附加段，用来指向额外的数据段，在大程序中可能会有用</li><li>SS (Stack Segment) 用来指向栈段的起始地址</li></ul><h3 id=栈段>栈段</h3><p>栈是一个具有后进先出(LIFO)的数据结构，只能从一端进行入栈(push)和出栈(pop)操作，具体细节不赘述。首先有一点要明确的是，栈段和其他的段本质上没有区别，栈只是人为创造的概念，而下面的 <code>push</code> 和 <code>pop</code> 指令也只是处理器为了配合这一概念所作出的支持，你仍然可以对栈段中的任意位置进行访问，这两个指令可以看作是处理器操作栈的 shortcuts。</p><p>定义栈需要初始化栈寄存器 <code>SS</code> 和栈指针 <code>SP</code>。</p><p>当我们使用 <code>push</code> 指令时，本质上是把操作数的内容存到了栈顶，相当于暂存了他的内容。以下指令是等价的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>push ax ; 将寄存器AX入栈。
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov cx, ax ; 将寄存器AX的内容放到CX中。
</span></span></code></pre></td></tr></table></div></div><p>当我们使用 <code>pop</code> 指令时，本质上是把当前栈顶中的内容赋给了操作数。以下指令的意图是等价的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pop dx ; 将寄存器DX出栈。
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov dx, cx ; 将寄存器CX中的内容放到DX中。
</span></span></code></pre></td></tr></table></div></div><h2 id=寻址>寻址</h2><p>需要注意的是，8086处理器可访问最大1MB的内存，也就是 2^20 字节，但是它的段寄存器和指令指针寄存器(<code>IP</code>)都是16位的，也就是最大只能访问 2^16 字节。为了实现这一目标，处理器在形成物理地址时，会先将16位段寄存器的内容左移4位，然后再和16位的偏移地址相加，便形成了20位的物理地址。</p><h3 id=寄存器寻址>寄存器寻址</h3><p>操作执行时，操作的数在寄存器中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov ax, cx
</span></span><span class=line><span class=cl>add bx, 0xf000
</span></span><span class=line><span class=cl>inc dx
</span></span></code></pre></td></tr></table></div></div><h3 id=立即寻址>立即寻址</h3><p>操作执行时，操作的数是一个立即数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>add bx, 0xf000
</span></span><span class=line><span class=cl>mov dx, label_a
</span></span></code></pre></td></tr></table></div></div><h3 id=内存寻址>内存寻址</h3><p>操作执行时，操作的数是一个偏移地址</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov ax, [0x5c0f] ; 物理地址由DS:0x5c0f组成
</span></span><span class=line><span class=cl>add word [0x0230], 0x5000 ; 物理地址由DS:0x0230组成
</span></span><span class=line><span class=cl>xor byte [es:label_b], 0x05 ; 物理地址由ES:label_b组成
</span></span></code></pre></td></tr></table></div></div><h3 id=基址寻址>基址寻址</h3><p>在指令的地址部分使用基址寄存器 BX 或者 BP 来提供偏移地址</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov [bx], dx
</span></span><span class=line><span class=cl>add byte [bx], 0x55
</span></span><span class=line><span class=cl>; 简而言之就是偏移量放在基址寄存器中，增加了灵活性
</span></span></code></pre></td></tr></table></div></div><p>基址寄存器也可以使用 BP。但与上面的例子不同的是，在形成20位的物理地址时，段寄存器使用的 SS 而不是默认的 DS。这意味着它常用于访问栈中的内容。</p><p>基址寻址还允许在基址寄存器上使用一个偏移量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov dx, [bp-2]
</span></span></code></pre></td></tr></table></div></div><p>处理器会将段寄存器(bx 时是 DS, bp 时是 SS)左移4位加上基址寄存器中的值并再加上或减去偏移量。</p><h3 id=变址寻址>变址寻址</h3><p>变址寻址与基址寻址类似，唯一的不同在于它使用的是变址寄存器 SI 或 DI, 而不是 基址寄存器 BX 或 BP。</p><h3 id=基址变址寻址>基址变址寻址</h3><p>基址变址寻址的操作数可以使用一个基址寄存器 (BX 或 BP), 外加一个变址寄存器 (SI 或 DI), 基本形式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov ax, [bx+si]
</span></span><span class=line><span class=cl>add word [bx+di], 0x3000
</span></span></code></pre></td></tr></table></div></div><p>可以将它类比为 C 语言中指针（基址寄存器）和偏移量（变址寄存器）的运算。</p><h2 id=用户程序的加载与运行>用户程序的加载与运行</h2><p>现在我们知道，一个在内存中的程序，是分为很多个区块的（段），而处理器的一系列段寄存器保存了各个段的基本信息（段起始地址）。但是，程序不可能一直存在于内存中，为了执行它，我们一般要首先将它从硬盘上加载到内存中。而在刚加载完成后，我们的段寄存器是没有这个程序的相关信息的，也就是说我们分不清这一大串0和1到底那一块是代码那一块是数据，也不知道从哪里开始执行。为此，我们可以约定一个程序的前N字节为程序头，而其中就包含了我们所需要的基本信息。一个示范的用户头如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 程序总长度
</span></span><span class=line><span class=cl>2. 程序入口点，即第一条指令的段地址和偏移量
</span></span><span class=line><span class=cl>3. 段重定位表项数
</span></span><span class=line><span class=cl>4. 段重定位表
</span></span></code></pre></td></tr></table></div></div><blockquote><p>注意这并不一定就真实世界用户程序的对应格式，只是为了讲解！</p></blockquote><h2 id=外部设备的访问>外部设备的访问</h2><p>处理器通过总线与各种 IO 设备交流。总线 (Bus) 可以认为是一排电线，所有的外围设备如键盘，显示器等包括处理器都连在总线上，而输入输出控制设备集中器( I/O Control Hub)则负责管理总线，决定哪个外围设备与处理器进行通信。</p><p>外围设备和处理器之间的通信是通过相应的 I/O 接口进行的。具体地说，处理器是通过端口(port)来和外围设备打交道的。本质上，端口就是一些寄存器，不过位于 I/O 接口电路中。</p><p>端口在不同的计算机系统中有不同的实现方式。在一些计算机系统中，端口号被映射到内存地址空间中。比如，0x00000 ~ 0xe0000 为真实内存地址，而 0xe0001 - 0xfffff 为 I/O 端口。而在另一些计算机系统中，端口是独立编址的，同时通过一个引脚来控制当前访问的是真实内存地址还是 I/O 端口。</p><p>下面通过独立编址，以个人计算机 PATA/SATA 接口为例，简要说明访问 I/O 端口的过程:</p><p>PATA/SATA 接口用于访问硬盘，有好几个端口，分别为命令端口，状态端口，参数端口和数据端口。而 ICH 芯片（一般意义上的南桥）通常集成了两个接口，分别为主硬盘和副硬盘。主硬盘分配的端口号是0x1f0~0x1f7,副硬盘分配的端口号是0x170~0x177。</p><p>读数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>in al, dx
</span></span><span class=line><span class=cl>in ax, dx
</span></span></code></pre></td></tr></table></div></div><p>in 指令的目的操作数必须是寄存器 <code>AL</code> 或者为 <code>AX</code>，当访问8位端口时，使用寄存器 <code>AL</code>, 访问16位端口时使用 <code>AX</code>。注意我们只能访问0~255号端口，下面指令时无效的！</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>in ax, 0x5fd
</span></span></code></pre></td></tr></table></div></div><p>写数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>out 0x37, al ; 写0x37端口（8位端口）
</span></span><span class=line><span class=cl>out 0xf5, ax ; 写0x37端口（16位端口）
</span></span><span class=line><span class=cl>out dx, al ; 写端口，具体数值在 dx 寄存器中（8位端口）
</span></span><span class=line><span class=cl>out dx, ax ; 写端口，具体数值在 dx 寄存器中（16位端口）
</span></span></code></pre></td></tr></table></div></div><p>out 指令的要求与 in 类似，不在赘述。</p><h2 id=中断>中断</h2><p>以通俗的话解释中断，就是在一些事件被触发后，处理器暂停当前的任务，并跳转到对应事件的处理程序中。当处理完毕时，再跳转回来之前的状态继续执行。</p><p>这些事件具体有哪些我们不做过多讨论，我们主要关注下处理器是如何处理这些中断的，因为某些情况下我们可能会想要复写这些中断处理程序。</p><h3 id=实模式下的中断向量表-interrupt-vector-table>实模式下的中断向量表 (Interrupt Vector Table)</h3><p>处理器可以识别256个中断，理论上就有256段处理程序。我们在物理地址起始处，即 0x00000 处开始的1KB空间内设置一个中断向量表，表有256项，每一项占2个字，即4个字节，刚好1KB。表的索引即为对应的中断号，而表项中的内容即为对应中断处理程序的实际地址。这样，当发生对应中断时，处理器就可以通过中断向量表找到对应中断处理程序的实际地址，并跳转过去执行。</p><h3 id=中断发生的过程>中断发生的过程</h3><ol><li>保护中断的现场。首先将标志寄存器压栈，并清除它的 IF 位和 TF 位。然后将代码寄存器 CS 和指令指针寄存器 IP 压栈。</li><li>执行中断处理程序。将终端号乘以4就得到了中断处理程序在表中的偏移地址。将中断程序的偏移地址和短地址分别传送给 IP 和 CS, 开始处理中断。</li><li>返回中断点继续执行。当执行到中断处理程序的最后一条指令 iret 时，处理器从栈中弹出 IP, CS 和 标志寄存器原本的内容，自此恢复执行。</li></ol></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://www.junz.org/post/asm_protectmode/><span class=mr-1.5>←</span><span>汇编语言之保护模式</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://www.junz.org/post/libcxx_string/><span>浅析 libc++ 中的 string 实现</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=https://www.junz.org>Jun's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>